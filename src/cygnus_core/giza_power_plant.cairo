// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//                                       .           .                  .⠀        .
//      █████████           ---======*.                       .         ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⠶⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//     ███░░░░░███                                              📡  .   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡏⠀⠀⠀⢹⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ███     ░░░  █████ ████  ███████ ████████   █████ ████  █████     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⠀⠹⣧⣀⣀⣀⣼⠏⠀⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//   ░███         ░░███ ░███  ███░░███░░███░░███ ░░███ ░███  ███░░      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⡟⠁⠀⠀⠈⠙⠛⠋⠁⠀⠀⠈⢻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//   ░███          ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███ ░░█████     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡏⠀⠀⠀⢀⣴⡾⠿⢷⣦⡀⠀⠀⠀⢹⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//   ░░███     ███ ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███  ░░░░██     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠁⠀⣠⣴⣾⣿⣶⣶⠀⢹⣷⣦⣄⠀⠈⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//    ░░█████████  ░░███████ ░░███████ ████ █████ ░░████████ ██████     ⢠⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣿⣤⣼⡟⠁⠀⠀⠀⠀⠀⠀⠀⠈⢻⣧⣤⣿⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⡄
//     ░░░░░░░░░    ░░░░░███  ░░░░░███░░░░ ░░░░░   ░░░░░░░░ ░░░░░░   .  ⢸⣯⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⢹⣿⣤⣀⣀⣀⠀⣀⣀⣀⣤⣿⡏⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣽⡇
//                  ███ ░███  ███ ░███ ⠀⠀⠀⠀ ⠀                           ⠀⢻⣯⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⢸⡇⠉⠉⠉⠙⣿⠋⠉⠉⠉⢸⡇⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⣽⡟⠀
//    .      *     ░░██████  ░░██████  ⠀   .    ------=======*          ⠀⠀⠙⢿⣿⡛⠛⠛⠛⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⣿⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠛⠛⠛⢛⣿⡿⠋⠀⠀
//                  ░░░░░░    ░░░░░░   ⠀                   .            ⠀⠀⠀⠀⠉⠛⠻⠷⠶⠶⠶⣶⡶⢾⡇⠀⠀⠀⠀⣿⠀⠀⠀⠀⢸⡷⢶⣶⠶⠶⠶⠾⠟⠛⠉⠀⠀⠀⠀
//                                     ⠀                            .   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣇⠘⣿⡄⠀⠀⠀⣿⠀⠀⠀⢠⣿⠃⣸⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//         https://cygnusdao.finance   ⠀          .        .            ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣆⠈⠻⣦⣄⣀⣿⣀⣠⣴⠟⠁⣰⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//                                     ⠀                                ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⣤⣈⠉⠛⠛⠛⠉⣁⣤⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//         Giza Power Plant 𓍝               .                  .        ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠃⠀⠀⠀⠘⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// Cygnus Factory in Cairo

// SPDX-License-Identifier: Unlicensed
%lang starknet

// Cairo libraries
from starkware.cairo.common.hash import hash2
from starkware.cairo.common.math import assert_not_zero, assert_not_equal
from starkware.cairo.common.bool import FALSE, TRUE
from starkware.cairo.common.alloc import alloc
from starkware.cairo.common.uint256 import Uint256, uint256_check
from starkware.cairo.common.cairo_builtins import HashBuiltin

// Starknet syscalls
from starkware.starknet.common.syscalls import deploy

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//
// @title  giza_power_plant
// @author CygnusDAO
//
// @notice This is the main Cygnus Factory on Starknet. This factory contract contains the records of all lending pools
//         deployed by Cygnus and it is the main security system for pools deployed on Starknet. Important addresses
//         such as the admin or dao vaults can only be set here.
//
//         Every collateral/borrow contract reports back here to check for:
//             - Admin address
//             - DAO revenue vault address
//             - Latest Cygnus oracle address
//
//         albireo_orbiter.cairo = borrowable deployer
//         deneb_orbiter.cairo = collateral deployer
//
//         Orbiters are the collateral and borrow deployers contracts which are not not part of the core contracts, but
//         instead are in charge of deploying the arms of core contracts with each other's addresses (borrow orbiter
//         deploys the borrow arm with the collateral address, and vice versa).
//
//         The steps to deploy a lending pool is as follows:
//             1. initialize lp token pair in oracle
//             2. initialize borrowable and collateral orbiters in this contract to get their unique ID
//             3. call `deploy_shuttle` with lp token pair and orbiter ID. ie deploy_shuttle(lp_token, 0)
//
//
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// Libraries
from src.cygnus_core.libraries.cygnus_pool_address import CygnusAddressLib
from src.cygnus_core.libraries.reentrancy_guard import ReentrancyGuard

// Interfaces
from src.cygnus_core.interfaces.interface_deneb_orbiter import IDenebOrbiter
from src.cygnus_core.interfaces.interface_albireo_orbiter import IAlbireoOrbiter
from src.cygnus_core.interfaces.interface_cygnus_nebula_oracle import ICygnusNebulaOracle

// Utils
from src.cygnus_core.utils.context import msg_sender, address_this

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     1. STRUCTS & CONSTANTS - INTERNAL
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

//
// @custom:struct Orbiter Official record of all orbiter addresses
// @custom:member initialized Whether or not this orbiter is active
// @custom:member orbiter_id The unique ID of the orbiter pair
// @custom:member orbiter_name A short string to easily identify what the orbiters were for (ie. dex name)
// @custom:member albireo_orbiter The address of the borrowable deployer
// @custom:member deneb_orbiter The address of the collateral deployer
//
struct CygnusOrbiter {
    initialized: felt,
    orbiter_id: felt,
    orbiter_name: felt,
    albireo_orbiter: felt,
    deneb_orbiter: felt,
}

//
// @custom:struct CygnusShuttle Official record of all lending pool addresses
// @custom:member launched Whether or not this lending pool is deployed
// @custom:member shuttle_id The unique ID of this lending pool
// @custom:member borrowable The address of the borrowable contract
// @custom:member collateral The address of the collateral contract
// @custom:member orbiter The struct containing the orbiters used to deploy this lending pool (if `launched` true)
//
struct CygnusShuttle {
    launched: felt,
    shuttle_id: felt,
    borrowable: felt,
    collateral: felt,
    orbiter_id: felt,
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     2. CUSTOM EVENTS - INTERNAL
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

//
// @notice Logs when a lending pool is successfuly deployed
// @param shuttle Shuttle Struct containing all the information of lending pool (borrowable address, collateral, etc.)
//
@event
func ShuttleDeploy(shuttle: CygnusShuttle) {
}

//
// @notice Logs when new orbiters are set
// @param orbiters Orbiter Struct containing the information of the initialized pool deployers
//
@event
func InitializeOrbiters(orbiter: CygnusOrbiter) {
}

//
// @notice Logs when a new cygnus admin is set
// @param old_admin The address of the factory admin up until now
// @param new_admin The address of the new factory admin
//
@event
func NewCygnusAdmin(old_admin: felt, new_admin: felt) {
}

//
// @notice Logs when a new DAO reserves address is set
// @param old_dao_reserves The address of the dao reserves up until now
// @param new_dao_reserves The address of the new dao reserves
//
@event
func NewDaoReserves(old_dao_reserves: felt, new_dao_reserves: felt) {
}

//
// @notice Logs when a new oracle is set (note: Only affects future deployments)
// @param old_price_oracle The address of the old Cygnus LP Oracle
// @param new_price_oracle The address of the new Cygnus LP Oracle
//
@event
func NewCygnusNebulaOracle(old_price_oracle: felt, new_price_oracle: felt) {
}

//
// @notice Logs when a new pending admin is set
// @param pending_admin The address of the pending admin, to be accepted as the new cygnus admin
// @param admin The address of the current admin, to accept the pending admin
//
@event
func NewPendingAdmin(pending_admin: felt, admin: felt) {
}

//
// @notice Logs when a new Cygnus admin is set
// @param old_admin The address of the cygnus admin until this point
// @param admin The address of the new cygnus admin
//
@event
func NewAdmin(old_admin: felt, admin: felt) {
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     3. STORAGE VARS - INTERNAL
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// Addresses ─────────────────────────────────────────

//
// @notice Stored name of this contract (`Giza Power Plant`)
//
@storage_var
func Name() -> (name: felt) {
}

//
// @notice Stored address of the current factory admin. Only this address may assign a new admin, revoking their
//         privileges.
//
@storage_var
func Admin() -> (admin: felt) {
}

//
// @notice Stored address of the user to be accepted by the current admin to be the new admin. The current Admin must
//         set a pending admin first before the new admin can be stored
//
@storage_var
func Pending_Admin() -> (pending_admin: felt) {
}

//
// @notice The reserves address where DAI reserves get minted to. The DAO accumulates reserves in the form of CygDAI
//
@storage_var
func Dao_Reserves() -> (dao_reserves: felt) {
}

//
// @notice Stored address of the contract to be accepted by the current admin to be the new dao reserves contract.
//
@storage_var
func Pending_Dao_Reserves() -> (pending_dao_reserves: felt) {
}

//
// @notice Stored address of the LP Price oracle used by all collateral lending pools. The oracle address is checked
//         during deployment of pools to assure it is active for the specific LP Token
//
@storage_var
func Cygnus_Nebula_Oracle() -> (cygnus_nebula_oracle: felt) {
}

//
// @notice The stored address of the borrow token, in our case DAI. All borrowable pools get deployed with an underlying
//         lending token and all collateral pools get deployed with an underlying LP Token.
//
@storage_var
func Dai() -> (dai: felt) {
    // alpha-goerli: 0x03e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9
    // mainnet: 0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3
}

// @notice The stored address of this chain`s native token. Not sure if needed (starknet sers wen?)
@storage_var
func Native_Token() -> (native_token: felt) {
}

// Mappings ──────────────────────────────────────────

//
// @notice Stored addresses of the borrowable and collateral deployers, which can be identified by their unique ID.
//         Once orbiters are initialized wtih `initialize_orbiter` an ID is created which cannot be overwritten.
//         Each has their unique `contract hash class` which is used to deploy borrow/collaterals.
// @param orbiter_id The unique ID of the pool deployers, which returns the orbiter struct
// @return orbiter Stored struct of this orbiter ID
//
@storage_var
func Orbiters(orbiter_id: felt) -> (orbiter: CygnusOrbiter) {
}

//
// @notice Stored lending pools identifiable by an LP Token address and the ID of the orbiters used to deploy this pair.
//         For example, the ID can refer to the DEX (jediswap, sithswap, etc.) or any other strategy we employ.
// @param lp_token_pair The address of the LP Token
// @param orbiter_id The Unique ID of the pool deployers used to deploy this lp_token_pair
// @return shuttle Stored struct of this Lending Pool, given an LP Token address and an orbiter ID
//
@storage_var
func Shuttles(lp_token_pair: felt, orbiter_id: felt) -> (shuttle: CygnusShuttle) {
}

//
// @notice Stored hash of the borrowable orbiter`s and collateral orbiter`s class hashes
// @param orbiter_hash The Hash2 of the borrowable class hash and the collateral class hash
// @return exists Whether or not this factory is using this exact orbiter pair
//
@storage_var
func Orbiters_Hash(orbiter_hash: felt) -> (exists: felt) {
}

// "Array" only for convinience with Lending Pools. Since shuttle ID gets stored in lending pools, could be easier for
// users to just search by ID instead of get_shuttles(lp_token_pair, orbiter_id).
// @param shuttle_id The lending pool ID
// @return shuttle The CygnusShuttle struct containing all the information of this lending pool
@storage_var
func All_Shuttles(shuttle_id: felt) -> (shuttle: CygnusShuttle) {
}

// Counters ──────────────────────────────────────────

//
// @notice Simple counter we use to keep track of total orbiter pairs deployed. The function `initialize_orbiters`
//         increases by 1 on every successful init
// @return total_orbiters Total number of orbiters used by this factory
//
@storage_var
func Total_Orbiters() -> (total_orbiters: felt) {
}

//
// @notice Same as the Total_Orbiters, but keeps a count of total lending pools deployed (ie highest shuttle_id),
//         increased by every successful `deploy_snuttle` call
// @return total_shuttles Total number of lending pools deployed by this factory
//
@storage_var
func Total_Shuttles() -> (total_shuttles: felt) {
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     4. CONSTRUCTOR
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

//
// @notice Constructs the factory on Starknet 🛸
// @param admin The address of the admin
// @param dao_reserves The address of the DAO reserves
// @param dai The address of DAI on Starknet
// @param cygnus_nebula_oracle The address of the LP oracle collateral pools use
//
@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    admin: felt, dao_reserves: felt, dai: felt, native_token: felt, cygnus_nebula_oracle: felt
) {
    //
    // ERORR: Doesn't get deployed
    //
    with_attr error_message {
        assert_not_zero(admin * dao_reserves * dai * cygnus_nebula_oracle);
    }

    // Factory
    Name.write(value='Cygnus: Giza Power Plant');

    // Admin
    Admin.write(value=admin);

    // Reserves
    Dao_Reserves.write(value=dao_reserves);

    // DAI
    Dai.write(value=dai);

    // ETH
    Native_Token.write(value=native_token);

    // Deployed oracle address
    Cygnus_Nebula_Oracle.write(value=cygnus_nebula_oracle);

    //
    // EVENT: NewCygnusAdmin
    //
    NewCygnusAdmin.emit(old_admin=0, new_admin=admin);

    //
    // EVENT: NewDaoReserves
    //
    NewDaoReserves.emit(old_dao_reserves=0, new_dao_reserves=dao_reserves);

    //
    // EVENT: NewCygnusNebulaOracle
    //
    NewCygnusNebulaOracle.emit(old_price_oracle=0, new_price_oracle=cygnus_nebula_oracle);

    return ();
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     5. STORAGE ACCESSORS - VIEW
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// @return name The name of this contract
//
@view
func name{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (name: felt) {
    return Name.read();
}

//
// @return admin The address of the current cygnus admin
//
@view
func admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (admin: felt) {
    return Admin.read();
}

//
// @return pending_admin The address of the pending factory admin
//
@view
func pending_admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    pending_admin: felt
) {
    return Pending_Admin.read();
}

//
// @return dao_reserves The address of the current Cygnus Dao reserves contract
//
@view
func dao_reserves{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    dao_reserves: felt
) {
    return Dao_Reserves.read();
}

//
// @return pending_dao_reserves The address of the pending Cygnus Dao reserves contract
//
@view
func pending_dao_reserves{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    pending_dao_reserves: felt
) {
    return Pending_Dao_Reserves.read();
}

//
// @return cygnus_nebula_oracle The address of the LP price oracle used by lending pools
//
@view
func cygnus_nebula_oracle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    cygnus_nebula_oracle: felt
) {
    return Cygnus_Nebula_Oracle.read();
}

//
// @return dai The address of DAI on Starknet
//
@view
func dai{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (dai: felt) {
    return Dai.read();
}

//
// @return native_token The address of Starknet's native token (if any)
//
@view
func native_token{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    native_token: felt
) {
    return Native_Token.read();
}

// Mappings and array

// Mapping[orbiter_id] = orbiter struct

//
// @notice Mapping to get an orbiter by its unique ID and return the stored record
// @param orbiter_id The ID of the orbiter pair
// @return orbiter The stored record of this orbiter (if any)
//
@view
func all_orbiters{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    orbiter_id: felt
) -> (
    initialized: felt,
    orbiter_id: felt,
    orbiter_name: felt,
    albireo_orbiter: felt,
    deneb_orbiter: felt,
) {
    // Get orbiter struct for the orbiter_id
    let (orbiter: CygnusOrbiter) = Orbiters.read(orbiter_id=orbiter_id);

    // Return values as returning structs since broken since v0.10
    return (
        initialized=orbiter.initialized,
        orbiter_id=orbiter.orbiter_id,
        orbiter_name=orbiter.orbiter_name,
        albireo_orbiter=orbiter.albireo_orbiter,
        deneb_orbiter=orbiter.deneb_orbiter,
    );
}

// counter

//
// @return total_orbiters The total amount of unique orbiter pairs stored
//
@view
func total_orbiters{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    total_orbiters: felt
) {
    return Total_Orbiters.read();
}

//
// @return total_shuttles The total amount of lending pools deployed
//
@view
func total_shuttles{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    total_shuttles: felt
) {
    return Total_Shuttles.read();
}

// Mapping[lp_token_pair][orbiter_id] = shuttle struct

//
// @notice Mapping to get a ledning pool by LP Token address and orbiter ID and return the stored record
// @param lp_token_pair The address of the LP Token
// @param orbiter_id The unique ID of the orbiters used to deploy this LP Token pair
//
@view
func get_shuttle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt, orbiter_id: felt
) -> (launched: felt, shuttle_id: felt, borrowable: felt, collateral: felt, orbiter_id: felt) {
    // Get shuttle from mapping
    let (shuttle: CygnusShuttle) = Shuttles.read(
        lp_token_pair=lp_token_pair, orbiter_id=orbiter_id
    );

    // return Shuttle struct
    return (
        launched=shuttle.launched,
        shuttle_id=shuttle.shuttle_id,
        borrowable=shuttle.borrowable,
        collateral=shuttle.collateral,
        orbiter_id=shuttle.orbiter_id,
    );
}

// array all_shuttles[index] = shuttle struct

//
// @notice "Array" of all structs
// @param shuttle_id The id of the lending pool
// @return shuttle The struct of the lending pool
//
@view
func all_shuttles{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    shuttle_id: felt
) -> (launched: felt, shuttle_id: felt, borrowable: felt, collateral: felt, orbiter_id: felt) {
    // Read from "array"
    let (shuttle: CygnusShuttle) = All_Shuttles.read(shuttle_id=shuttle_id);

    // Return values instead of struct since Cairo v0.10.0 broke returning structs
    return (
        launched=shuttle.launched,
        shuttle_id=shuttle.shuttle_id,
        borrowable=shuttle.borrowable,
        collateral=shuttle.collateral,
        orbiter_id=shuttle.orbiter_id,
    );
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     6. CONSTANT FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

//
// @notice Reverts if msg.sender is not admin
//
func cygnus_admin_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // factory admin address
    let (cygnus_admin: felt) = Admin.read();

    //
    // ERROR: caller_not_admin
    //
    with_attr error_message("cygnus_factory__caller_not_admin") {
        // check caller not 0 address
        assert_not_zero(msg_sender());
        // check caller is cygnus admin, else revert
        assert msg_sender() = cygnus_admin;
    }

    return ();
}

//
// @notice Used in `initialize_orbiters` to avoid duplicate pairs
// @param albireo_orbiter The address of the borrowbale deployer
// @param deneb_orbiter The address of the collateral deployer
//
func check_orbiters_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    albireo_orbiter: felt, deneb_orbiter: felt
) {
    // get the deployed bytecode hash of the borrowable (ie class hash)
    let (borrowable_class_hash: felt) = IAlbireoOrbiter.borrowable_class_hash(
        contract_address=albireo_orbiter
    );

    // get the deployed bytecode hash of the collateral
    let (collateral_class_hash: felt) = IDenebOrbiter.collateral_class_hash(
        contract_address=deneb_orbiter
    );

    // get the pedersen hash of the new borrowable and collateral deployers class hash
    let (orbiter_hash: felt) = hash2{hash_ptr=pedersen_ptr}(
        borrowable_class_hash, collateral_class_hash
    );

    // check the hash against the mapping(hash => bool)
    let (exists: felt) = Orbiters_Hash.read(orbiter_hash);

    //
    // ERROR: orbiters_already_initialized
    //
    with_attr error_message(
            "cygnus_factory__orbiters_already_initialized({albireo_orbiter}, {deneb_orbiter})") {
        // assert hash uniqueness
        assert exists = FALSE;
    }

    // write unique hash of orbiters to storage
    Orbiters_Hash.write(orbiter_hash, 1);

    return ();
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     7. NON-CONSTANT FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

// @notice Called only when deploying a new lending pool
// @param lp_token_pair The address of the LP Token
// @param orbiter_id The unique ID of the orbiters used to deploy this lending pool
// @return shuttle The shuttle struct with unitialized variables except for lending pool ID
func board_shuttle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt, orbiter: CygnusOrbiter
) -> (shuttle: CygnusShuttle) {
    // check storage if this new lending pool exists
    let (new_shuttle: CygnusShuttle) = Shuttles.read(lp_token_pair, orbiter.orbiter_id);

    //
    // ERROR: shuttle_already_deployed
    //
    with_attr error_message("cygnus_factory__shuttle_already_deployed({lp_token_pair})") {
        // reverts if a lending pool with this same LP Token and Orbiter ID already exists
        // doesnt get reassigned
        assert new_shuttle.shuttle_id = 0;
    }

    // Get the total amount of shuttles deployed up to this point
    let (new_shuttle_id: felt) = total_shuttles();

    // Create lending pool object and just assign the unique ID for now
    tempvar shuttle = CygnusShuttle(
        launched=0,
        shuttle_id=new_shuttle_id,
        borrowable=0,
        collateral=0,
        orbiter_id=orbiter.orbiter_id,
        );

    // Update total deployed lending pools ++
    Total_Shuttles.write(new_shuttle_id + 1);

    // Return struct to the deploy function
    return (shuttle=shuttle);
}

// ─────────────────────────────────────────────────── External ───────────────────────────────────────────────────────

// @notice Deploys a new lending pool, consists of 5 phases:
//         Phase 1: Orbiter check
//                  - Orbiters (deployers) are active and usable
//                  - Reverts if check doesn't pass
//         Phase 2: Board shuttle check
//                  - No shuttle with the same LP Token has been deployed before
//                  - Reverts if pool is already deployed
//         Phase 3: Deploy Collateral and Borrow contracts
//                  - Calculate address of collateral and deploy borrow contract with calculated collateral address
//                  - Deploy the collateral contract with the deployed borrow address
//                  - revert if calculated collateral address is different than deployed
//         Phase 4: Price Oracle check:
//                  - Assert price oracle exists for this LP Token pair
//                  - Reverts if LP Token is not supported
//         Phase 5: Initialize shuttle
//                  - Initialize and store record of this shuttle in this contract
//                  - No reverts
// @custom:security non-reentrant
@external
func deploy_shuttle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt, orbiter_id: felt, base_rate_per_year: felt, multiplier_per_year: felt
) -> (borrowable: felt, collateral: felt) {
    alloc_locals;

    // Lock
    ReentrancyGuard._start();

    //
    // ERROR: lp_token_cant_be_zero
    //
    with_attr error_message("cygnus_factory__lp_token_cant_be_zero({lp_token_pair})") {
        // avoid deploying without an LP token pair
        assert_not_zero(lp_token_pair);
    }

    // ─────────────────────────────── Phase 1 ───────────────────────────────

    // Load orbiter struct to use the deployers
    let (orbiter: CygnusOrbiter) = Orbiters.read(orbiter_id);

    //
    // ERROR: orbiters_are_inactive
    //
    with_attr error_message("cygnus_factory__orbiters_are_inactive({orbiter_id})") {
        // avoid deploying if orbiters are inactive or dont exist
        assert orbiter.initialized = TRUE;
    }

    // ─────────────────────────────── Phase 2 ───────────────────────────────

    // Create shuttle struct, reverts if LP Token already exists.
    let (shuttle: CygnusShuttle) = board_shuttle(lp_token_pair, orbiter);

    // ─────────────────────────────── Phase 3 ───────────────────────────────

    // Deploy collateral and borrowable

    // salt of lp token + factory
    let (salt: felt) = hash2{hash_ptr=pedersen_ptr}(lp_token_pair, address_this());

    // Get hash from deployer
    let (collateral_class_hash: felt) = IDenebOrbiter.collateral_class_hash(
        contract_address=orbiter.deneb_orbiter
    );

    // Calculate future collateral address
    let (constructor_calldata: felt*) = alloc();

    // Calculate collateral address internallyy
    let (calculated_collateral: felt) = CygnusAddressLib.calculate_contract_address{
        hash_ptr=pedersen_ptr
    }(salt, collateral_class_hash, 0, constructor_calldata, orbiter.deneb_orbiter);

    // ───────────────────────────────

    let (borrow_token: felt) = Dai.read();

    // Deploy borrowable with calculated collateral address
    let (borrowable: felt) = IAlbireoOrbiter.deploy_borrowable(
        contract_address=orbiter.albireo_orbiter,
        collateral=calculated_collateral,
        underlying=borrow_token,
        shuttle_id=shuttle.shuttle_id,
        base_rate_per_year=base_rate_per_year,
        multiplier_per_year=multiplier_per_year,
    );

    // Deploy collateral with deployed borrowable address
    let (collateral: felt) = IDenebOrbiter.deploy_collateral(
        contract_address=orbiter.deneb_orbiter,
        borrowable=borrowable,
        underlying=lp_token_pair,
        shuttle_id=shuttle.shuttle_id,
    );

    // ERROR: collateral_address_mismatch
    with_attr error_message("cygnus_factory__collateral_address_mismatch()") {
        // avoid if calculated collateral address is different than deployed
        assert collateral = calculated_collateral;
    }

    // ─────────────────────────────── Phase 4 ───────────────────────────────

    // Get oracle
    let (cygnus_oracle: felt) = Cygnus_Nebula_Oracle.read();

    // Check if oracle is initialized for this LP Token, reverts if not initialized on next exec call
    let (_, oracle_initialized: felt, _, _) = ICygnusNebulaOracle.get_nebula_oracle(
        contract_address=cygnus_oracle, lp_token_pair=lp_token_pair
    );

    //
    // ERROR: lp_token_pair_not_supported
    //
    with_attr error_message("cygnus_factory__lp_token_pair_not_supported({lp_token_pair})") {
        // avoid deploying if oracle is not initialized
        assert oracle_initialized = TRUE;
    }

    // ─────────────────────────────── Phase 5 ───────────────────────────────

    // Create temp lending pool object with deployed info
    tempvar shuttle = CygnusShuttle(
        launched=1,
        shuttle_id=shuttle.shuttle_id,
        borrowable=borrowable,
        collateral=collateral,
        orbiter_id=orbiter.orbiter_id,
        );

    // Write lending pool to Shuttles mapping
    Shuttles.write(lp_token_pair, orbiter.orbiter_id, shuttle);

    // "push" lending pool to Shuttles array
    All_Shuttles.write(shuttle.shuttle_id, shuttle);

    //
    // EVENT: ShuttleDeploy
    //
    ShuttleDeploy.emit(shuttle);

    // Unlock
    ReentrancyGuard._end();

    // Return deployed contracts addresses
    return (borrowable=borrowable, collateral=collateral);
}

//
// @notice initializes borrowable and collateral deployers and assigns them a unique ID to use for deployment
// @param name Name to identify what these deployers are for (ie Jediswap, Sithswap, etc.)
// @param albireo_orbiter Address of the borrowable deployer
// @param deneb_orbiter Address of the collateral deployer
//
@external
func initialize_orbiters{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    name: felt, albireo_orbiter: felt, deneb_orbiter: felt
) {
    // total orbiters length
    let (total_orbiters: felt) = Total_Orbiters.read();

    // reverts if orbiters already exist
    check_orbiters_internal(albireo_orbiter, deneb_orbiter);

    // make orbiter struct
    tempvar orbiter = CygnusOrbiter(
        initialized=TRUE,
        orbiter_id=total_orbiters,
        orbiter_name=name,
        albireo_orbiter=albireo_orbiter,
        deneb_orbiter=deneb_orbiter,
        );

    // store orbiters in orbiters mapping - mapping(orbiter_id => Orbiter)
    Orbiters.write(total_orbiters, orbiter);

    // add counter
    Total_Orbiters.write(total_orbiters + 1);

    // EVENT: InitializeOrbiters
    InitializeOrbiters.emit(orbiter);

    return ();
}

//
// @notice Admin only 👽
// @notice Sets a new pending admin to be accepted by the current admin
// @param new_pending_admin The address of the new pending admin
// @custom:security non-reentrant
//
@external
func set_pending_admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    new_pending_admin: felt
) {
    // lock
    ReentrancyGuard._start();

    // revert if not admin
    cygnus_admin_internal();

    // address of current admin
    let (admin: felt) = Admin.read();

    // ERROR: admin_already_set
    with_attr error_message("cygnus_factory__admin_already_set({new_pending_admin})") {
        assert_not_equal(new_pending_admin, admin);
    }

    // write to storage
    Pending_Admin.write(value=new_pending_admin);

    // EVENT: NewPendingAdmin
    NewPendingAdmin.emit(pending_admin=new_pending_admin, admin=admin);

    // unlock
    ReentrancyGuard._end();

    return ();
}

//
// @notice Admin only 👽
// @notice accepts the pending admin and resigns privileges
// @custom:security non-reentrant
//
@external
func set_admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // lock
    ReentrancyGuard._start();

    // revert if not admin
    cygnus_admin_internal();

    // get pending admin
    let (new_admin: felt) = Pending_Admin.read();

    //
    // ERROR: admin_cant_be_zero
    //
    with_attr error_message("cygnus_factory__admin_cant_be_zero()") {
        assert_not_zero(new_admin);
    }

    // address of the current admin
    let (old_admin: felt) = Admin.read();

    // assign new admin
    Admin.write(value=new_admin);

    // remove pending admin back to 0
    Pending_Admin.write(0);

    //
    // EVENT: NewAdmin
    //
    NewAdmin.emit(old_admin=old_admin, admin=new_admin);

    // unlock
    ReentrancyGuard._end();

    return ();
}

//
// @param new_cygnus_oracle The address of the new cygnus lp oracle
//
@external
func set_new_cygnus_oracle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    new_cygnus_oracle: felt
) {
    // lock
    ReentrancyGuard._start();

    // revert if not admin
    cygnus_admin_internal();

    let (cygnus_oracle: felt) = Cygnus_Nebula_Oracle.read();

    //
    // ERROR: oracle_already_set
    //
    with_attr error_message("cygnus_factory__oracle_already_set({new_cygnus_oracle})") {
        assert_not_equal(new_cygnus_oracle, cygnus_oracle);
    }

    //
    // ERROR: oracle_cant_be_zero
    //
    with_attr error_message("cygnus_factory__oracle_cant_be_zero({new_cygnus_oracle})") {
        assert_not_zero(new_cygnus_oracle);
    }

    // write to storage
    Cygnus_Nebula_Oracle.write(value=new_cygnus_oracle);

    // @custom:event NewCygnusNebulaOracle
    NewCygnusNebulaOracle.emit(old_price_oracle=cygnus_oracle, new_price_oracle=new_cygnus_oracle);

    // unlock
    ReentrancyGuard._end();

    return ();
}
