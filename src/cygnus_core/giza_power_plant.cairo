// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                                       .           .                  .â €        .
//      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ           ---======*.                       .         â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â£ â£¶â ¶â£¶â£„â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
//     â–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆ                                              ðŸ“¡  .   â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â£¼â¡â €â €â €â¢¹â£§â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
//    â–ˆâ–ˆâ–ˆ     â–‘â–‘â–‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â£¤â €â ¹â£§â£€â£€â£€â£¼â â €â£¤â¡€â €â €â €â €â €â €â €â €â €â €â €â €â €
//   â–‘â–ˆâ–ˆâ–ˆ         â–‘â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆâ–‘â–‘â–ˆâ–ˆâ–ˆ â–‘â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–‘â–‘      â €â €â €â €â €â €â €â €â €â €â €â €â£´â¡Ÿâ â €â €â ˆâ ™â ›â ‹â â €â €â ˆâ¢»â£¦â €â €â €â €â €â €â €â €â €â €â €â €
//   â–‘â–ˆâ–ˆâ–ˆ          â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ  â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â €â €â €â €â €â €â €â €â €â €â €â£¸â¡â €â €â €â¢€â£´â¡¾â ¿â¢·â£¦â¡€â €â €â €â¢¹â£‡â €â €â €â €â €â €â €â €â €â €â €
//   â–‘â–‘â–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ  â–‘â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ  â–‘â–‘â–‘â–‘â–ˆâ–ˆ     â €â €â €â €â €â €â €â €â €â €â €â£¿â â €â£ â£´â£¾â£¿â£¶â£¶â €â¢¹â£·â£¦â£„â €â ˆâ£¿â €â €â €â €â €â €â €â €â €â €â €
//    â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â¢ â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¿â£¤â£¼â¡Ÿâ â €â €â €â €â €â €â €â ˆâ¢»â£§â£¤â£¿â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â£¤â¡„
//     â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘    â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆ  â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ â–‘â–‘â–‘â–‘â–‘   â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ â–‘â–‘â–‘â–‘â–‘â–‘   .  â¢¸â£¯â£€â£€â£€â£€â£€â¡€â €â €â €â €â €â¢¹â£¿â£¤â£€â£€â£€â €â£€â£€â£€â£¤â£¿â¡â €â €â €â €â €â¢€â£€â£€â£€â£€â£€â£½â¡‡
//                  â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ â–‘â–ˆâ–ˆâ–ˆ â €â €â €â € â €                           â €â¢»â£¯â ‰â ‰â ‰â ‰â â €â €â €â €â €â¢¸â¡‡â ‰â ‰â ‰â ™â£¿â ‹â ‰â ‰â ‰â¢¸â¡‡â €â €â €â €â €â ˆâ ‰â ‰â ‰â ‰â£½â¡Ÿâ €
//    .      *     â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â €   .    ------=======*          â €â €â ™â¢¿â£¿â¡›â ›â ›â ›â €â €â €â €â¢¸â¡‡â €â €â €â €â£¿â €â €â €â €â¢¸â¡‡â €â €â €â €â ›â ›â ›â¢›â£¿â¡¿â ‹â €â €
//                  â–‘â–‘â–‘â–‘â–‘â–‘    â–‘â–‘â–‘â–‘â–‘â–‘   â €                   .            â €â €â €â €â ‰â ›â »â ·â ¶â ¶â ¶â£¶â¡¶â¢¾â¡‡â €â €â €â €â£¿â €â €â €â €â¢¸â¡·â¢¶â£¶â ¶â ¶â ¶â ¾â Ÿâ ›â ‰â €â €â €â €
//                                     â €                            .   â €â €â €â €â €â €â €â €â €â €â €â¢»â£‡â ˜â£¿â¡„â €â €â €â£¿â €â €â €â¢ â£¿â ƒâ£¸â¡Ÿâ €â €â €â €â €â €â €â €â €â €â €
//         https://cygnusdao.finance   â €          .        .            â €â €â €â €â €â €â €â €â €â €â €â ˆâ¢¿â£†â ˆâ »â£¦â£„â£€â£¿â£€â£ â£´â Ÿâ â£°â¡¿â â €â €â €â €â €â €â €â €â €â €â €
//                                     â €                                â €â €â €â €â €â €â €â €â €â €â €â €â €â ™â¢·â£¤â£ˆâ ‰â ›â ›â ›â ‰â£â£¤â¡¾â ‹â €â €â €â €â €â €â €â €â €â €â €â €â €
//         Giza Power Plant ð“               .                  .        â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â ‰â ™â ƒâ €â €â €â ˜â ‹â ‰â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Cygnus Factory in Cairo

// SPDX-License-Identifier: Unlicensed
%lang starknet

// Cairo libraries
from starkware.cairo.common.hash import hash2
from starkware.cairo.common.math import assert_not_zero, assert_not_equal
from starkware.cairo.common.bool import FALSE, TRUE
from starkware.cairo.common.alloc import alloc
from starkware.cairo.common.uint256 import Uint256, uint256_check
from starkware.cairo.common.cairo_builtins import HashBuiltin

// Starknet syscalls
from starkware.starknet.common.syscalls import deploy

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// @title  giza_power_plant
// @author CygnusDAO
//
// @notice This is the main Cygnus Factory on Starknet. This factory contract contains the records of all lending pools
//         deployed by Cygnus and it is the main security system for pools deployed on Starknet. Important addresses
//         such as the admin or dao vaults can only be set here.
//
//         Every collateral/borrow contract reports back here to check for:
//             - Admin address
//             - DAO revenue vault address
//             - Latest Cygnus oracle address
//
//         albireo_orbiter.cairo = borrowable deployer
//         deneb_orbiter.cairo = collateral deployer
//
//         Orbiters are the collateral and borrow deployers contracts which are not not part of the core contracts, but
//         instead are in charge of deploying the arms of core contracts with each other's addresses (borrow orbiter
//         deploys the borrow arm with the collateral address, and vice versa).
//
//         The steps to deploy a lending pool is as follows:
//             1. initialize lp token pair in oracle
//             2. initialize borrowable and collateral orbiters in this contract to get their unique ID
//             3. call `deploy_shuttle` with lp token pair and orbiter ID. ie deploy_shuttle(lp_token, 0)
//
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Libraries
from src.cygnus_core.libraries.cygnus_pool_address import CygnusAddressLib
from src.cygnus_core.libraries.reentrancy_guard import ReentrancyGuard

// Interfaces
from src.cygnus_core.interfaces.interface_deneb_orbiter import IDenebOrbiter
from src.cygnus_core.interfaces.interface_albireo_orbiter import IAlbireoOrbiter
from src.cygnus_core.interfaces.interface_cygnus_nebula_oracle import ICygnusNebulaOracle

// Utils
from src.cygnus_core.utils.context import msg_sender, address_this

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     1. STRUCTS & CONSTANTS - INTERNAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//
// @custom:struct Orbiter Official record of all orbiter addresses
// @custom:member initialized Whether or not this orbiter is active
// @custom:member orbiter_id The unique ID of the orbiter pair
// @custom:member orbiter_name A short string to easily identify what the orbiters were for (ie. dex name)
// @custom:member albireo_orbiter The address of the borrowable deployer
// @custom:member deneb_orbiter The address of the collateral deployer
//
struct CygnusOrbiter {
    initialized: felt,
    orbiter_id: felt,
    orbiter_name: felt,
    albireo_orbiter: felt,
    deneb_orbiter: felt,
}

//
// @custom:struct CygnusShuttle Official record of all lending pool addresses
// @custom:member launched Whether or not this lending pool is deployed
// @custom:member shuttle_id The unique ID of this lending pool
// @custom:member borrowable The address of the borrowable contract
// @custom:member collateral The address of the collateral contract
// @custom:member orbiter The struct containing the orbiters used to deploy this lending pool (if `launched` true)
//
struct CygnusShuttle {
    launched: felt,
    shuttle_id: felt,
    borrowable: felt,
    collateral: felt,
    orbiter_id: felt,
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     2. CUSTOM EVENTS - INTERNAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//
// @notice Logs when a lending pool is successfuly deployed
// @param shuttle Shuttle Struct containing all the information of lending pool (borrowable address, collateral, etc.)
//
@event
func ShuttleDeploy(shuttle: CygnusShuttle) {
}

//
// @notice Logs when new orbiters are set
// @param orbiters Orbiter Struct containing the information of the initialized pool deployers
//
@event
func InitializeOrbiters(orbiter: CygnusOrbiter) {
}

//
// @notice Logs when a new cygnus admin is set
// @param old_admin The address of the factory admin up until now
// @param new_admin The address of the new factory admin
//
@event
func NewCygnusAdmin(old_admin: felt, new_admin: felt) {
}

//
// @notice Logs when a new DAO reserves address is set
// @param old_dao_reserves The address of the dao reserves up until now
// @param new_dao_reserves The address of the new dao reserves
//
@event
func NewDaoReserves(old_dao_reserves: felt, new_dao_reserves: felt) {
}

//
// @notice Logs when a new oracle is set (note: Only affects future deployments)
// @param old_price_oracle The address of the old Cygnus LP Oracle
// @param new_price_oracle The address of the new Cygnus LP Oracle
//
@event
func NewCygnusNebulaOracle(old_price_oracle: felt, new_price_oracle: felt) {
}

//
// @notice Logs when a new pending admin is set
// @param pending_admin The address of the pending admin, to be accepted as the new cygnus admin
// @param admin The address of the current admin, to accept the pending admin
//
@event
func NewPendingAdmin(pending_admin: felt, admin: felt) {
}

//
// @notice Logs when a new Cygnus admin is set
// @param old_admin The address of the cygnus admin until this point
// @param admin The address of the new cygnus admin
//
@event
func NewAdmin(old_admin: felt, admin: felt) {
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     3. STORAGE VARS - INTERNAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Addresses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//
// @notice Stored name of this contract (`Giza Power Plant`)
//
@storage_var
func Name() -> (name: felt) {
}

//
// @notice Stored address of the current factory admin. Only this address may assign a new admin, revoking their
//         privileges.
//
@storage_var
func Admin() -> (admin: felt) {
}

//
// @notice Stored address of the user to be accepted by the current admin to be the new admin. The current Admin must
//         set a pending admin first before the new admin can be stored
//
@storage_var
func Pending_Admin() -> (pending_admin: felt) {
}

//
// @notice The reserves address where DAI reserves get minted to. The DAO accumulates reserves in the form of CygDAI
//
@storage_var
func Dao_Reserves() -> (dao_reserves: felt) {
}

//
// @notice Stored address of the contract to be accepted by the current admin to be the new dao reserves contract.
//
@storage_var
func Pending_Dao_Reserves() -> (pending_dao_reserves: felt) {
}

//
// @notice Stored address of the LP Price oracle used by all collateral lending pools. The oracle address is checked
//         during deployment of pools to assure it is active for the specific LP Token
//
@storage_var
func Cygnus_Nebula_Oracle() -> (cygnus_nebula_oracle: felt) {
}

//
// @notice The stored address of the borrow token, in our case DAI. All borrowable pools get deployed with an underlying
//         lending token and all collateral pools get deployed with an underlying LP Token.
//
@storage_var
func Dai() -> (dai: felt) {
    // alpha-goerli: 0x03e85bfbb8e2a42b7bead9e88e9a1b19dbccf661471061807292120462396ec9
    // mainnet: 0x00da114221cb83fa859dbdb4c44beeaa0bb37c7537ad5ae66fe5e0efd20e6eb3
}

// @notice The stored address of this chain`s native token. Not sure if needed (starknet sers wen?)
@storage_var
func Native_Token() -> (native_token: felt) {
}

// Mappings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//
// @notice Stored addresses of the borrowable and collateral deployers, which can be identified by their unique ID.
//         Once orbiters are initialized wtih `initialize_orbiter` an ID is created which cannot be overwritten.
//         Each has their unique `contract hash class` which is used to deploy borrow/collaterals.
// @param orbiter_id The unique ID of the pool deployers, which returns the orbiter struct
// @return orbiter Stored struct of this orbiter ID
//
@storage_var
func Orbiters(orbiter_id: felt) -> (orbiter: CygnusOrbiter) {
}

//
// @notice Stored lending pools identifiable by an LP Token address and the ID of the orbiters used to deploy this pair.
//         For example, the ID can refer to the DEX (jediswap, sithswap, etc.) or any other strategy we employ.
// @param lp_token_pair The address of the LP Token
// @param orbiter_id The Unique ID of the pool deployers used to deploy this lp_token_pair
// @return shuttle Stored struct of this Lending Pool, given an LP Token address and an orbiter ID
//
@storage_var
func Shuttles(lp_token_pair: felt, orbiter_id: felt) -> (shuttle: CygnusShuttle) {
}

//
// @notice Stored hash of the borrowable orbiter`s and collateral orbiter`s class hashes
// @param orbiter_hash The Hash2 of the borrowable class hash and the collateral class hash
// @return exists Whether or not this factory is using this exact orbiter pair
//
@storage_var
func Orbiters_Hash(orbiter_hash: felt) -> (exists: felt) {
}

// "Array" only for convinience with Lending Pools. Since shuttle ID gets stored in lending pools, could be easier for
// users to just search by ID instead of get_shuttles(lp_token_pair, orbiter_id).
// @param shuttle_id The lending pool ID
// @return shuttle The CygnusShuttle struct containing all the information of this lending pool
@storage_var
func All_Shuttles(shuttle_id: felt) -> (shuttle: CygnusShuttle) {
}

// Counters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//
// @notice Simple counter we use to keep track of total orbiter pairs deployed. The function `initialize_orbiters`
//         increases by 1 on every successful init
// @return total_orbiters Total number of orbiters used by this factory
//
@storage_var
func Total_Orbiters() -> (total_orbiters: felt) {
}

//
// @notice Same as the Total_Orbiters, but keeps a count of total lending pools deployed (ie highest shuttle_id),
//         increased by every successful `deploy_snuttle` call
// @return total_shuttles Total number of lending pools deployed by this factory
//
@storage_var
func Total_Shuttles() -> (total_shuttles: felt) {
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     4. CONSTRUCTOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//
// @notice Constructs the factory on Starknet ðŸ›¸
// @param admin The address of the admin
// @param dao_reserves The address of the DAO reserves
// @param dai The address of DAI on Starknet
// @param cygnus_nebula_oracle The address of the LP oracle collateral pools use
//
@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    admin: felt, dao_reserves: felt, dai: felt, native_token: felt, cygnus_nebula_oracle: felt
) {
    //
    // ERORR: Doesn't get deployed
    //
    with_attr error_message {
        assert_not_zero(admin * dao_reserves * dai * cygnus_nebula_oracle);
    }

    // Factory
    Name.write(value='Cygnus: Giza Power Plant');

    // Admin
    Admin.write(value=admin);

    // Reserves
    Dao_Reserves.write(value=dao_reserves);

    // DAI
    Dai.write(value=dai);

    // ETH
    Native_Token.write(value=native_token);

    // Deployed oracle address
    Cygnus_Nebula_Oracle.write(value=cygnus_nebula_oracle);

    //
    // EVENT: NewCygnusAdmin
    //
    NewCygnusAdmin.emit(old_admin=0, new_admin=admin);

    //
    // EVENT: NewDaoReserves
    //
    NewDaoReserves.emit(old_dao_reserves=0, new_dao_reserves=dao_reserves);

    //
    // EVENT: NewCygnusNebulaOracle
    //
    NewCygnusNebulaOracle.emit(old_price_oracle=0, new_price_oracle=cygnus_nebula_oracle);

    return ();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     5. STORAGE ACCESSORS - VIEW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// @return name The name of this contract
//
@view
func name{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (name: felt) {
    return Name.read();
}

//
// @return admin The address of the current cygnus admin
//
@view
func admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (admin: felt) {
    return Admin.read();
}

//
// @return pending_admin The address of the pending factory admin
//
@view
func pending_admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    pending_admin: felt
) {
    return Pending_Admin.read();
}

//
// @return dao_reserves The address of the current Cygnus Dao reserves contract
//
@view
func dao_reserves{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    dao_reserves: felt
) {
    return Dao_Reserves.read();
}

//
// @return pending_dao_reserves The address of the pending Cygnus Dao reserves contract
//
@view
func pending_dao_reserves{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    pending_dao_reserves: felt
) {
    return Pending_Dao_Reserves.read();
}

//
// @return cygnus_nebula_oracle The address of the LP price oracle used by lending pools
//
@view
func cygnus_nebula_oracle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    cygnus_nebula_oracle: felt
) {
    return Cygnus_Nebula_Oracle.read();
}

//
// @return dai The address of DAI on Starknet
//
@view
func dai{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (dai: felt) {
    return Dai.read();
}

//
// @return native_token The address of Starknet's native token (if any)
//
@view
func native_token{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    native_token: felt
) {
    return Native_Token.read();
}

// Mappings and array

// Mapping[orbiter_id] = orbiter struct

//
// @notice Mapping to get an orbiter by its unique ID and return the stored record
// @param orbiter_id The ID of the orbiter pair
// @return orbiter The stored record of this orbiter (if any)
//
@view
func all_orbiters{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    orbiter_id: felt
) -> (
    initialized: felt,
    orbiter_id: felt,
    orbiter_name: felt,
    albireo_orbiter: felt,
    deneb_orbiter: felt,
) {
    // Get orbiter struct for the orbiter_id
    let (orbiter: CygnusOrbiter) = Orbiters.read(orbiter_id=orbiter_id);

    // Return values as returning structs since broken since v0.10
    return (
        initialized=orbiter.initialized,
        orbiter_id=orbiter.orbiter_id,
        orbiter_name=orbiter.orbiter_name,
        albireo_orbiter=orbiter.albireo_orbiter,
        deneb_orbiter=orbiter.deneb_orbiter,
    );
}

// counter

//
// @return total_orbiters The total amount of unique orbiter pairs stored
//
@view
func total_orbiters{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    total_orbiters: felt
) {
    return Total_Orbiters.read();
}

//
// @return total_shuttles The total amount of lending pools deployed
//
@view
func total_shuttles{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    total_shuttles: felt
) {
    return Total_Shuttles.read();
}

// Mapping[lp_token_pair][orbiter_id] = shuttle struct

//
// @notice Mapping to get a ledning pool by LP Token address and orbiter ID and return the stored record
// @param lp_token_pair The address of the LP Token
// @param orbiter_id The unique ID of the orbiters used to deploy this LP Token pair
//
@view
func get_shuttle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt, orbiter_id: felt
) -> (launched: felt, shuttle_id: felt, borrowable: felt, collateral: felt, orbiter_id: felt) {
    // Get shuttle from mapping
    let (shuttle: CygnusShuttle) = Shuttles.read(
        lp_token_pair=lp_token_pair, orbiter_id=orbiter_id
    );

    // return Shuttle struct
    return (
        launched=shuttle.launched,
        shuttle_id=shuttle.shuttle_id,
        borrowable=shuttle.borrowable,
        collateral=shuttle.collateral,
        orbiter_id=shuttle.orbiter_id,
    );
}

// array all_shuttles[index] = shuttle struct

//
// @notice "Array" of all structs
// @param shuttle_id The id of the lending pool
// @return shuttle The struct of the lending pool
//
@view
func all_shuttles{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    shuttle_id: felt
) -> (launched: felt, shuttle_id: felt, borrowable: felt, collateral: felt, orbiter_id: felt) {
    // Read from "array"
    let (shuttle: CygnusShuttle) = All_Shuttles.read(shuttle_id=shuttle_id);

    // Return values instead of struct since Cairo v0.10.0 broke returning structs
    return (
        launched=shuttle.launched,
        shuttle_id=shuttle.shuttle_id,
        borrowable=shuttle.borrowable,
        collateral=shuttle.collateral,
        orbiter_id=shuttle.orbiter_id,
    );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     6. CONSTANT FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

//
// @notice Reverts if msg.sender is not admin
//
func cygnus_admin_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // factory admin address
    let (cygnus_admin: felt) = Admin.read();

    //
    // ERROR: caller_not_admin
    //
    with_attr error_message("cygnus_factory__caller_not_admin") {
        // check caller not 0 address
        assert_not_zero(msg_sender());
        // check caller is cygnus admin, else revert
        assert msg_sender() = cygnus_admin;
    }

    return ();
}

//
// @notice Used in `initialize_orbiters` to avoid duplicate pairs
// @param albireo_orbiter The address of the borrowbale deployer
// @param deneb_orbiter The address of the collateral deployer
//
func check_orbiters_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    albireo_orbiter: felt, deneb_orbiter: felt
) {
    // get the deployed bytecode hash of the borrowable (ie class hash)
    let (borrowable_class_hash: felt) = IAlbireoOrbiter.borrowable_class_hash(
        contract_address=albireo_orbiter
    );

    // get the deployed bytecode hash of the collateral
    let (collateral_class_hash: felt) = IDenebOrbiter.collateral_class_hash(
        contract_address=deneb_orbiter
    );

    // get the pedersen hash of the new borrowable and collateral deployers class hash
    let (orbiter_hash: felt) = hash2{hash_ptr=pedersen_ptr}(
        borrowable_class_hash, collateral_class_hash
    );

    // check the hash against the mapping(hash => bool)
    let (exists: felt) = Orbiters_Hash.read(orbiter_hash);

    //
    // ERROR: orbiters_already_initialized
    //
    with_attr error_message(
            "cygnus_factory__orbiters_already_initialized({albireo_orbiter}, {deneb_orbiter})") {
        // assert hash uniqueness
        assert exists = FALSE;
    }

    // write unique hash of orbiters to storage
    Orbiters_Hash.write(orbiter_hash, 1);

    return ();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//     7. NON-CONSTANT FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// @notice Called only when deploying a new lending pool
// @param lp_token_pair The address of the LP Token
// @param orbiter_id The unique ID of the orbiters used to deploy this lending pool
// @return shuttle The shuttle struct with unitialized variables except for lending pool ID
func board_shuttle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt, orbiter: CygnusOrbiter
) -> (shuttle: CygnusShuttle) {
    // check storage if this new lending pool exists
    let (new_shuttle: CygnusShuttle) = Shuttles.read(lp_token_pair, orbiter.orbiter_id);

    //
    // ERROR: shuttle_already_deployed
    //
    with_attr error_message("cygnus_factory__shuttle_already_deployed({lp_token_pair})") {
        // reverts if a lending pool with this same LP Token and Orbiter ID already exists
        // doesnt get reassigned
        assert new_shuttle.shuttle_id = 0;
    }

    // Get the total amount of shuttles deployed up to this point
    let (new_shuttle_id: felt) = total_shuttles();

    // Create lending pool object and just assign the unique ID for now
    tempvar shuttle = CygnusShuttle(
        launched=0,
        shuttle_id=new_shuttle_id,
        borrowable=0,
        collateral=0,
        orbiter_id=orbiter.orbiter_id,
        );

    // Update total deployed lending pools ++
    Total_Shuttles.write(new_shuttle_id + 1);

    // Return struct to the deploy function
    return (shuttle=shuttle);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ External â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// @notice Deploys a new lending pool, consists of 5 phases:
//         Phase 1: Orbiter check
//                  - Orbiters (deployers) are active and usable
//                  - Reverts if check doesn't pass
//         Phase 2: Board shuttle check
//                  - No shuttle with the same LP Token has been deployed before
//                  - Reverts if pool is already deployed
//         Phase 3: Deploy Collateral and Borrow contracts
//                  - Calculate address of collateral and deploy borrow contract with calculated collateral address
//                  - Deploy the collateral contract with the deployed borrow address
//                  - revert if calculated collateral address is different than deployed
//         Phase 4: Price Oracle check:
//                  - Assert price oracle exists for this LP Token pair
//                  - Reverts if LP Token is not supported
//         Phase 5: Initialize shuttle
//                  - Initialize and store record of this shuttle in this contract
//                  - No reverts
// @custom:security non-reentrant
@external
func deploy_shuttle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    lp_token_pair: felt, orbiter_id: felt, base_rate_per_year: felt, multiplier_per_year: felt
) -> (borrowable: felt, collateral: felt) {
    alloc_locals;

    // Lock
    ReentrancyGuard._start();

    //
    // ERROR: lp_token_cant_be_zero
    //
    with_attr error_message("cygnus_factory__lp_token_cant_be_zero({lp_token_pair})") {
        // avoid deploying without an LP token pair
        assert_not_zero(lp_token_pair);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Phase 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Load orbiter struct to use the deployers
    let (orbiter: CygnusOrbiter) = Orbiters.read(orbiter_id);

    //
    // ERROR: orbiters_are_inactive
    //
    with_attr error_message("cygnus_factory__orbiters_are_inactive({orbiter_id})") {
        // avoid deploying if orbiters are inactive or dont exist
        assert orbiter.initialized = TRUE;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Phase 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Create shuttle struct, reverts if LP Token already exists.
    let (shuttle: CygnusShuttle) = board_shuttle(lp_token_pair, orbiter);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Phase 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Deploy collateral and borrowable

    // salt of lp token + factory
    let (salt: felt) = hash2{hash_ptr=pedersen_ptr}(lp_token_pair, address_this());

    // Get hash from deployer
    let (collateral_class_hash: felt) = IDenebOrbiter.collateral_class_hash(
        contract_address=orbiter.deneb_orbiter
    );

    // Calculate future collateral address
    let (constructor_calldata: felt*) = alloc();

    // Calculate collateral address internallyy
    let (calculated_collateral: felt) = CygnusAddressLib.calculate_contract_address{
        hash_ptr=pedersen_ptr
    }(salt, collateral_class_hash, 0, constructor_calldata, orbiter.deneb_orbiter);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let (borrow_token: felt) = Dai.read();

    // Deploy borrowable with calculated collateral address
    let (borrowable: felt) = IAlbireoOrbiter.deploy_borrowable(
        contract_address=orbiter.albireo_orbiter,
        collateral=calculated_collateral,
        underlying=borrow_token,
        shuttle_id=shuttle.shuttle_id,
        base_rate_per_year=base_rate_per_year,
        multiplier_per_year=multiplier_per_year,
    );

    // Deploy collateral with deployed borrowable address
    let (collateral: felt) = IDenebOrbiter.deploy_collateral(
        contract_address=orbiter.deneb_orbiter,
        borrowable=borrowable,
        underlying=lp_token_pair,
        shuttle_id=shuttle.shuttle_id,
    );

    // ERROR: collateral_address_mismatch
    with_attr error_message("cygnus_factory__collateral_address_mismatch()") {
        // avoid if calculated collateral address is different than deployed
        assert collateral = calculated_collateral;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Phase 4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Get oracle
    let (cygnus_oracle: felt) = Cygnus_Nebula_Oracle.read();

    // Check if oracle is initialized for this LP Token, reverts if not initialized on next exec call
    let (_, oracle_initialized: felt, _, _) = ICygnusNebulaOracle.get_nebula_oracle(
        contract_address=cygnus_oracle, lp_token_pair=lp_token_pair
    );

    //
    // ERROR: lp_token_pair_not_supported
    //
    with_attr error_message("cygnus_factory__lp_token_pair_not_supported({lp_token_pair})") {
        // avoid deploying if oracle is not initialized
        assert oracle_initialized = TRUE;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Phase 5 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Create temp lending pool object with deployed info
    tempvar shuttle = CygnusShuttle(
        launched=1,
        shuttle_id=shuttle.shuttle_id,
        borrowable=borrowable,
        collateral=collateral,
        orbiter_id=orbiter.orbiter_id,
        );

    // Write lending pool to Shuttles mapping
    Shuttles.write(lp_token_pair, orbiter.orbiter_id, shuttle);

    // "push" lending pool to Shuttles array
    All_Shuttles.write(shuttle.shuttle_id, shuttle);

    //
    // EVENT: ShuttleDeploy
    //
    ShuttleDeploy.emit(shuttle);

    // Unlock
    ReentrancyGuard._end();

    // Return deployed contracts addresses
    return (borrowable=borrowable, collateral=collateral);
}

//
// @notice initializes borrowable and collateral deployers and assigns them a unique ID to use for deployment
// @param name Name to identify what these deployers are for (ie Jediswap, Sithswap, etc.)
// @param albireo_orbiter Address of the borrowable deployer
// @param deneb_orbiter Address of the collateral deployer
//
@external
func initialize_orbiters{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    name: felt, albireo_orbiter: felt, deneb_orbiter: felt
) {
    // total orbiters length
    let (total_orbiters: felt) = Total_Orbiters.read();

    // reverts if orbiters already exist
    check_orbiters_internal(albireo_orbiter, deneb_orbiter);

    // make orbiter struct
    tempvar orbiter = CygnusOrbiter(
        initialized=TRUE,
        orbiter_id=total_orbiters,
        orbiter_name=name,
        albireo_orbiter=albireo_orbiter,
        deneb_orbiter=deneb_orbiter,
        );

    // store orbiters in orbiters mapping - mapping(orbiter_id => Orbiter)
    Orbiters.write(total_orbiters, orbiter);

    // add counter
    Total_Orbiters.write(total_orbiters + 1);

    // EVENT: InitializeOrbiters
    InitializeOrbiters.emit(orbiter);

    return ();
}

//
// @notice Admin only ðŸ‘½
// @notice Sets a new pending admin to be accepted by the current admin
// @param new_pending_admin The address of the new pending admin
// @custom:security non-reentrant
//
@external
func set_pending_admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    new_pending_admin: felt
) {
    // lock
    ReentrancyGuard._start();

    // revert if not admin
    cygnus_admin_internal();

    // address of current admin
    let (admin: felt) = Admin.read();

    // ERROR: admin_already_set
    with_attr error_message("cygnus_factory__admin_already_set({new_pending_admin})") {
        assert_not_equal(new_pending_admin, admin);
    }

    // write to storage
    Pending_Admin.write(value=new_pending_admin);

    // EVENT: NewPendingAdmin
    NewPendingAdmin.emit(pending_admin=new_pending_admin, admin=admin);

    // unlock
    ReentrancyGuard._end();

    return ();
}

//
// @notice Admin only ðŸ‘½
// @notice accepts the pending admin and resigns privileges
// @custom:security non-reentrant
//
@external
func set_admin{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // lock
    ReentrancyGuard._start();

    // revert if not admin
    cygnus_admin_internal();

    // get pending admin
    let (new_admin: felt) = Pending_Admin.read();

    //
    // ERROR: admin_cant_be_zero
    //
    with_attr error_message("cygnus_factory__admin_cant_be_zero()") {
        assert_not_zero(new_admin);
    }

    // address of the current admin
    let (old_admin: felt) = Admin.read();

    // assign new admin
    Admin.write(value=new_admin);

    // remove pending admin back to 0
    Pending_Admin.write(0);

    //
    // EVENT: NewAdmin
    //
    NewAdmin.emit(old_admin=old_admin, admin=new_admin);

    // unlock
    ReentrancyGuard._end();

    return ();
}

//
// @param new_cygnus_oracle The address of the new cygnus lp oracle
//
@external
func set_new_cygnus_oracle{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    new_cygnus_oracle: felt
) {
    // lock
    ReentrancyGuard._start();

    // revert if not admin
    cygnus_admin_internal();

    let (cygnus_oracle: felt) = Cygnus_Nebula_Oracle.read();

    //
    // ERROR: oracle_already_set
    //
    with_attr error_message("cygnus_factory__oracle_already_set({new_cygnus_oracle})") {
        assert_not_equal(new_cygnus_oracle, cygnus_oracle);
    }

    //
    // ERROR: oracle_cant_be_zero
    //
    with_attr error_message("cygnus_factory__oracle_cant_be_zero({new_cygnus_oracle})") {
        assert_not_zero(new_cygnus_oracle);
    }

    // write to storage
    Cygnus_Nebula_Oracle.write(value=new_cygnus_oracle);

    // @custom:event NewCygnusNebulaOracle
    NewCygnusNebulaOracle.emit(old_price_oracle=cygnus_oracle, new_price_oracle=new_cygnus_oracle);

    // unlock
    ReentrancyGuard._end();

    return ();
}
