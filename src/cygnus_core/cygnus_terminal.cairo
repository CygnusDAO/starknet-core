// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//                                       .           .
//      █████████           ---======*.                       .             .              .
//     ███░░░░░███                                              📡  .               .              🌔
//    ███     ░░░  █████ ████  ███████ ████████   █████ ████  █████  ⠀⠀⠀⠀ .  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//   ░███         ░░███ ░███  ███░░███░░███░░███ ░░███ ░███  ███░░   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                      .
//   ░███          ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███ ░░█████  ⠀⠀⠀🛰️⠀⠀⠀⠀⠀⠀ .
//   ░░███     ███ ░███ ░███ ░███ ░███ ░███ ░███  ░███ ░███  ░░░░██  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀.   🛸        .
//    ░░█████████  ░░███████ ░░███████ ████ █████ ░░████████ ██████
//     ░░░░░░░░░    ░░░░░███  ░░░░░███░░░░ ░░░░░   ░░░░░░░░ ░░░░░░   ⠀⠀.⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀             .
//                  ███ ░███  ███ ░███ ⠀⠀⠀---========*.⠀⠀⠀⠀⠀⠀⠀⠀.⠀⠀⠀⠀ ⠀ 🛸⠀⠀ ⠀⠀.⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀
//    .      *     ░░██████  ░░██████  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣄⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠛⠒⠂⠈⢷⣄⠀ ⠀⠀⠀⠀⠀⠀  .
//                  ░░░░░░    ░░░░░░   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡔⡓⠚⢷⣄⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⢀⠔⠓⠒⠲⠶⠶⠶⠦⠀⠻ ⣄⡀⠀⠀⠀⠀⠀
//      .                            . ⠀⠀⠀⠀⠀⠀⠀⠀⠀🛸⠀⠀⠀⠀⠀⠀⠀⠀⣴⣋⣉⣉⣉⣈⢻⣷⣄ ⠀ ⠀ ⠀⠀⠀⠀⠀⠀⣠⠞⠓⠒⠒⠒⠶⠶⠶⠖⠒⠀ ⠞⢿⣿⣦⡀⠀⠀
//                                     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⡤⠤⠄⣠⣎⣀⣀⣀⣀⣀⣀⣀⣙⣿⣷⣤        ⣠⠟⠱⠶⠶⠶⠶⠶⠶⠶⠤⠤⠤⠤ ⠄⠠⠿⣽⣿⣮⡉⠀⠀⠀⠀
//    https://cygnusdao.finance        ⠀⠀⠀⠀⢀⣀⣀⣀⣠⡤⠤⠤⠴⠒⢒⣞⣁⣀⣀⣀⣀⣀⣠⣤⣄⡀⠨⢷⣿⡷⣞   ⣠⠞⠡⠤⠤⠤⠤⣤⣤⣤⣤⣀⣀⣀ ⣀⣀ ⣀⡀⠀⢘⢿⣿⣿⡦⣤⠀⠀⠀⠀
//                                     ⠀⠀⠀⠀⠈⠁⠀⢀⠀⣠⡤⠒⢀⣶⣁⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠻⡿⠮⣣⠞⠁⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠈ ⠉⠀⠈⠉⠻⣽⣯⣿⠣⠖⠄⠀⠀⠀⠀⠀
//    Cygnus-finance in Cairo          ⣀⣈⣉⣭⣽⠶⠾⠗⢊⣡⠤⠤⠯⠶⠶⠒⠒⠒⠂⠀⠀⠐⠦⠤⠤⠬⠬⠤⠤⢙⠞⢁⠀⠀⢈⣉⣉⣉⣉⣭⠭⠭⠭⠭⠭⠭⠭⠭⢭⣥⣀⣀ ⣒⣒⠒⠙⢶⡫⠴⠮⢍⣈⡒
//
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// Smart contracts to `go long` on your LP Token.
//
//     Deposit LP Token, borrow DAI.
//
//     Structure of all Cygnus Contracts:
//
//     Starknet
//       │
//       ├ 1. Structs & Mappings
//       │     └ Internal
//       ├ 2. Events                    @events                               contract events
//       ├ 3. Storage                   @storage_vars                         contract state variables
//       │     └ Internal
//       ├ 4. Constructor               @constructor                          constructor or 'initializer'
//       ├ 5. Storage Getters           @view                                 getters for @storage_vars
//       │     └ External
//       ├ 6. Constant Functions        @l1_handler && @view                  non state-changing functions
//       │     ├ Internal
//       │     └ External
//       └ 7. Non-Constant Functions    @l1_handler && @external              state-changing function
//             ├ Internal
//             └ External
//
//      @dev All storage is held in this contract, and not in `libraries` (namespaces). We chose to import all functions
//           instead of the namespace design pattern. Namespaces are only imported when the contract itself only has a
//           few functions (SafeERC20, ReentrancyGuard, etc.). The library functions are also imported.
//
//
//      Naming convention used:
//
//      @storage_vars                   Pascal_Case_With_Underscores          Total_Balance, Total_Borrrows
//      @constrctor                     snake_case                            constructor, contract_name_initializer
//      @l1_handler                     snake_case                            increase_balance_l1_handler
//      @view                           snake_case                            get_debt_ratio, get_lp_token
//      @external                       snake_case                            seize_tokens, leverage_lp_token
//      @contract_interface             IPascalCase                           IERC20, ICygnusFactory, ICygnusTerminal
//      @events                         PascalCase
//
//      structs                         PascalCase                            ShuttleDeploy, BorrowSnapshot
//      functions                       snake_case                            mint, mint_internal
//      local, tempvar, let             snake_case                            cygnus_admin, get_caller_address
//      const                           UPPER_CASE_WITH_UNDERSCORES           INITIAL_EXCHANGE_RATE
//      error_message                   contract_name__error_description      cygnus_terminal__not_valid_uint256()
//
//      All file names in snake_case (incl. interfaces) but their namespaces following solidity convention (IERC20, 
//      ICygnusCollateral, ICygnusFactory, etc.)

// SPDX-License-Identifier: Unlicensed
%lang starknet

// Cairo standard libraries
from starkware.cairo.common.bool import FALSE, TRUE
from starkware.cairo.common.math import assert_not_zero
from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.uint256 import Uint256, uint256_eq, uint256_le, uint256_lt

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//
// @title  cygnus_terminal
// @author cygnusdao
// @notice Terminal contract for Cygnus which handles deposits of assets and the minting of the pool tokens.
//         The borrowable arm allows users to deposit DAI and in turn they receive CygDAI. The collateral arm allows
//         users to deposit LP Tokens and in turn they receive CygLP. The `underlying` variable refers to the address
//         of the borrow token (DAI) and the address of the collateral token (address of an LP Token).
//
//         This factory contract contains the records of all shuttles deployed by Cygnus.
//         Every collateral/borrow contract reports back here to:
//             - Check admin address (to increase debt ratios, update interest rate model, set void, etc.)
//             - Check reserves manager address when minting new DAO reserves (in CygnusBorrow.sol) or to add
//               DAO liquidation fees if any (in CygnusCollateral.sol)
//
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// Dependencies -> ERC20
from src.cygnus_core.erc20 import (
    erc20_initializer,
    Total_Supply,
    spend_allowance_internal,
    mint_internal,
    burn_internal,
)

// Interfaces
from src.cygnus_core.interfaces.interface_erc20 import IERC20
from src.cygnus_core.interfaces.interface_giza_power_plant import IGizaPowerPlant

// Libraries
from src.cygnus_core.libraries.safemath import SafeUint256
from src.cygnus_core.libraries.safe_erc20 import SafeERC20
from src.cygnus_core.libraries.reentrancy_guard import ReentrancyGuard

// Utils
from src.cygnus_core.utils.context import msg_sender, address_this

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     2. CUSTOM EVENTS
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// @notice Logs when assets are deposited and shares are minted
// @param from_ The address that deposited the assets
// @param to: The address that received the shares
// @param assets The amount of assets deposited
// @param shares The amount of shares minted
@event
func Deposit(from_: felt, to: felt, assets: Uint256, shares: Uint256) {
}

// @notice Logs when shares are redeemed and assets are withdrawn
// @param from_ The address of the account redeeming the shares
// @param to The address who is receiving the assets
// @param owner The address of the owner of the shares
// @param assets The amount of assets withdrawn
// @param shares The amount of shares redeemed and burnt
@event
func Withdraw(from_: felt, to: felt, owner: felt, assets: Uint256, shares: Uint256) {
}

// @notice Logs when total balance of assets is synced with real balance
// @param total_balance The total balance of assets held by this contract (LP Tokens or DAI)
@event
func Sync(total_balance: Uint256) {
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     3. STORAGE - INTERNAL
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// @notice Total balance held by this contract in terms of the underlying (DAI or LP Tokens)
@storage_var
func Total_Balance() -> (total_balance: Uint256) {
}

// @notice Address of the underlying asset
@storage_var
func Underlying() -> (underlying: felt) {
}

// @notice The Cygnus factory address on this chain
@storage_var
func Giza_Power_Plant() -> (giza_power_plant: felt) {
}

// @notice The unique lending pool ID
@storage_var
func Shuttle_ID() -> (shuttle_id: felt) {
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     4. CONSTRUCTOR
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// @notice Constructs the Terminal contract. We set an initializer instead of a constructor as Cairo only
//         supports 1 constructor per contract. The constructors for borrow and collateral contracts are found
//         in `cygnus_borrow_control` and `cygnus_collateral_control`
// @param name The name of the pool token
// @param symbol The symbol of the pool token
// @param decimals The number of decimals used to get its user representation.
func cygnus_terminal_initializer{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    name: felt, symbol: felt, decimals: felt
) {
    return erc20_initializer(name, symbol, decimals);
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     5. STORAGE GETTERS - EXTERNAL
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// @return total_balance The total balance of assets (DAI for borrowable, LP Token for collateral)
@view
func total_balance{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    total_balance: Uint256
) {
    return Total_Balance.read();
}

// @return underlying The address of the underlying asset (DAI address for borrowable, LP Token address for collateral)
@view
func underlying{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    underlying: felt
) {
    return Underlying.read();
}

// @return giza_power_plant The address of the Cygnus factory on Starknet
@view
func giza_power_plant{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    giza_power_plant: felt
) {
    return Giza_Power_Plant.read();
}

// @return shuttle_id The lending pool ID that is shares by both collateral and borrowable contracts
@view
func shuttle_id{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    shuttle_id: felt
) {
    return Shuttle_ID.read();
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//      6. CONSTANT FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

// @notice Reverts if msg.sender is not factory admin, used by borrow_control and collateral_control contracts
func cygnus_admin_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // read factory address from storage
    let (cygnus_factory_address: felt) = Giza_Power_Plant.read();

    // read factory admin from the factory
    let (cygnus_admin: felt) = IGizaPowerPlant.admin(contract_address=cygnus_factory_address);

    // @custom:error caller_not_admin Avoid tx unless admin
    with_attr error_message("cygnus_terminal__caller_not_admin") {
        // check caller is cygnus admin, else revert
        assert msg_sender() = cygnus_admin;
    }

    return ();
}

// ─────────────────────────────────────────────────── External ───────────────────────────────────────────────────────

// @notice Calculates the exchange rate between the balance of assets and the pool tokens, initial rate is 1 to 1
// @return exchange_rate The current exchange rate
@view
func exchange_rate{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() -> (
    exchange_rate: Uint256
) {
    alloc_locals;

    // current total supply of pool tokens
    let (total_supply_stored: Uint256) = Total_Supply.read();

    // Check if supply is equal to 0
    let (supply_is_zero: felt) = uint256_eq(total_supply_stored, Uint256(0, 0));

    // If supply is 0, return initial exchange rate
    if (supply_is_zero == TRUE) {
        // return 1e18
        return (exchange_rate=Uint256(10 ** 18, 0));
    }

    // current total balance of assets
    let (total_balance_stored: Uint256) = Total_Balance.read();

    // total balance * scale / supply
    let (exchange_rate: Uint256, _) = SafeUint256.div_fixed(
        total_balance_stored, total_supply_stored
    );

    return (exchange_rate=exchange_rate);
}

// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//     7. NON-CONSTANT FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────── Internal ───────────────────────────────────────────────────────

// @notice Updates total_balance storage after function calls, used as a modifier basically
func update_internal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}() {
    // Get address of underlying asset
    let (underlying: felt) = Underlying.read();

    // Get total amount of assets held by this contract
    let (balance: Uint256) = IERC20.balanceOf(contract_address=underlying, account=address_this());

    // Write updated balance to storage
    Total_Balance.write(balance);

    // @custom:event Sync
    Sync.emit(balance);

    return ();
}

// @notice Before withdraw hook for strategies
func before_withdraw_internal(assets: Uint256, shares: Uint256) {
    return ();
}

// @notice After deposit hook for strategies
func after_deposit_internal(assets: Uint256, shares: Uint256) {
    return ();
}

// ─────────────────────────────────────────────────── External ───────────────────────────────────────────────────────

// @notice Erc4626 compatible deposit function, receives assets and mints shares to the recipient
// @param assets Amount of assets to deposit to receive shares
// @param recipient The address receiving shares
// @return shares The amount of shares minted
// @custom:security non-reentrant
func deposit_terminal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    assets: Uint256, recipient: felt
) -> (shares: Uint256) {
    alloc_locals;

    // lock
    ReentrancyGuard._start();

    //
    // 1. Get current exchange rate
    //
    let (current_exchange_rate: Uint256) = exchange_rate();

    //
    // 2. Calculate shares to mint
    //
    let (shares: Uint256, _) = SafeUint256.div_fixed(assets, current_exchange_rate);

    // ERORR: cant_mint_zero_shares
    with_attr error_message("cygnus_terminal__cant_mint_zero_shares({assets})") {
        // revert if assets is 0
        assert_not_zero(shares.low + shares.high);
    }

    //
    // 3. Transfer underlying asset from msg.sender to this contract
    //

    // Get underlying asset
    let (underlying: felt) = Underlying.read();

    // Transfer asset from caller
    SafeERC20.transferFrom(
        contract_address=underlying, sender=msg_sender(), recipient=address_this(), amount=assets
    );

    //
    // 4. Mint shares to recipient
    //
    mint_internal(recipient, shares);

    // internal deposit hook
    after_deposit_internal(assets, shares);

    //
    // EVENT: Deposit
    //
    Deposit.emit(msg_sender(), recipient, assets, shares);

    // Update modifier
    update_internal();

    // unlock
    ReentrancyGuard._end();

    return (shares=shares);
}

// @notice Erc4626 compatible redeem function, burns shares and returns assets
// @param shares Amount of shares to redeem to receive back  assets
// @param recipient The address of the recipient of the assets
// @param owner THe address of the owner of the shares
// @return assets The amount of assets withdrawn
// @custom:security non-reentrant
func redeem_terminal{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    shares: Uint256, recipient: felt, owner: felt
) -> (assets: Uint256) {
    alloc_locals;

    // Lock
    ReentrancyGuard._start();

    //
    // 1. Check allowance from owner to msg.sender. spend_allowance_internal returns if msg_sender == owner
    //
    spend_allowance_internal(owner, msg_sender(), shares);

    //
    // 2. Get current exchange rate
    //
    let (current_exchange_rate: Uint256) = exchange_rate();

    //
    // 3. Calculate assets to withdraw
    //
    let (assets: Uint256) = SafeUint256.mul_fixed(shares, current_exchange_rate);

    //
    // ERORR: cant_redeem_zero_assets
    //
    with_attr error_message("cygnus_terminal__cant_redeem_zero_assets()") {
        // revert if assets is 0
        assert_not_zero(assets.low + assets.high);
    }

    //
    // ERROR: redeem_amount_invalid
    //
    with_attr error_message("cygnus_terminal__redeem_amount_invalid()") {
        // total_balance
        let (total_balance_stored: Uint256) = Total_Balance.read();
        // total_balance < assets
        let (total_balance_is_less: felt) = uint256_lt(total_balance_stored, assets);
        // revert if assets is more than balance
        assert total_balance_is_less = FALSE;
    }

    // strategy hook (if any)
    before_withdraw_internal(assets, shares);

    //
    // 4. Burn the shares from `owner`
    //
    burn_internal(owner, shares);

    //
    // 5. Transfer underlying asset from this contract to `recipient`
    //

    // Get underlying
    let (underlying: felt) = Underlying.read();

    // transfer assets to recipient
    SafeERC20.transfer(contract_address=underlying, recipient=recipient, amount=assets);

    //
    // EVENT: Withdraw
    //
    Withdraw.emit(msg_sender(), owner, recipient, assets, shares);

    // Update modifier
    update_internal();

    // Unlock
    ReentrancyGuard._end();

    return (assets=assets);
}

